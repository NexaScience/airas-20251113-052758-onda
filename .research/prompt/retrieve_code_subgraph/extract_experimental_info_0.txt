
Input:
You are a researcher with expertise in engineering in the field of machine learning.

# Instructions
- The content described in “Repository Content” corresponds to the GitHub repository of the method described in “Method.”
- Please extract the following two pieces of information from “Repository Content”:
    - experimental_code：Extract the implementation sections that are directly related to the method described in “Method.”
    - experimental_info：Extract and output the experimental settings related to the method described in “Method.”

# Method
DNN-MFBO employs a stacked architecture of neural networks, where each NN models one fidelity. For fidelities m > 1, the NN's input concatenates the original input with the output from the previous fidelity, `xm = [x; fm-1(x)]`, allowing information propagation and complex relationship learning. The NN output is `fm(x) = w^T_m φ_θ_m (xm)`. Output layer weights `wm` are treated as random variables with a standard normal prior, while other NN weights `θm` are hyper-parameters. A stochastic variational learning algorithm, leveraging the reparameterization trick, jointly estimates the Gaussian posterior `q(wm)` and hyper-parameters by maximizing a variational evidence lower bound (ELBO). The acquisition function is `a(x, m) = (1/λm) * I(f*, fm(x)|D)`. Computing this involves approximating posterior output distributions `p(fm(x)|D)` as Gaussian using fidelity-wise moment matching and Gauss-Hermite quadrature. The conditional entropy term `Ep(f*|D)[H(fm(x)|f*, D)]` is approximated via Monte-Carlo sampling of `f*` and by computing `H(fm(x)|fM(x) ≤ f*, D)`, again using sequential quadrature and moment matching to approximate conditional posteriors as Gaussian. Acquisition function optimization uses automatic differentiation and L-BFGS.

# Repository Content
File Path: test_functions/python_related/generate_simudata3.py
Content:
#!/usr/bin/env python
# Copyright (c) 2017 Zi Wang
from push_world import *
import sys


if __name__ == '__main__':
    rx = float(sys.argv[1])
    ry = float(sys.argv[2])
    gx = float(sys.argv[4])
    gy = float(sys.argv[5])
    simu_steps = int(float(sys.argv[3]) * 10)
    
    # set it to False if no gui needed
    world = b2WorldInterface(False)
    oshape, osize, ofriction, odensity, bfriction, hand_shape, hand_size  = 'circle', 1, 0.01, 0.05, 0.01, 'rectangle', (0.3,1) 
    thing,base = make_thing(500, 500, world, oshape, osize, ofriction, odensity, bfriction, (0,0))

    init_angle = np.arctan(ry/rx)
    robot = end_effector(world, (rx,ry), base, init_angle, hand_shape, hand_size)
    ret = simu_push(world, thing, robot, base, simu_steps)
    ret = np.linalg.norm(np.array([gx, gy]) - ret)
    sys.stdout.write(str(ret))
File Path: test_functions/python_related/generate_simudata4.py
Content:
#!/usr/bin/env python
# Copyright (c) 2017 Zi Wang
from push_world import *
import sys

# difference to generate_simudata is an input that control angle of push
if __name__ == '__main__':
    rx = float(sys.argv[1])
    ry = float(sys.argv[2])
    gx = float(sys.argv[4])
    gy = float(sys.argv[5])
    init_angle = float(sys.argv[6])
    simu_steps = int(float(sys.argv[3]) * 10)
    # Set the parameter to True if need gui
    world = b2WorldInterface(False)
    oshape, osize, ofriction, odensity, bfriction, hand_shape, hand_size  = 'circle', 1, 0.01, 0.05, 0.01, 'rectangle', (0.3,1) 
    thing,base = make_thing(500, 500, world, oshape, osize, ofriction, odensity, bfriction, (0,0))
    xvel = -rx;
    yvel = -ry;
    regu = np.linalg.norm([xvel,yvel])
    xvel = xvel / regu * 10;
    yvel = yvel / regu * 10;
    robot = end_effector(world, (rx,ry), base, init_angle, hand_shape, hand_size)
    ret = simu_push2(world, thing, robot, base, xvel, yvel, simu_steps)
    ret = np.linalg.norm(np.array([gx, gy]) - ret)
    sys.stdout.write(str(ret))
File Path: test_functions/python_related/generate_simudata_2robot2thing.py
Content:
#!/usr/bin/env python
# Copyright (c) 2017 Zi Wang
from push_world import *
import sys

# difference to generate_simudata is an input that control angle of push
if __name__ == '__main__':
    rx = float(sys.argv[1])
    ry = float(sys.argv[2])
    xvel = float(sys.argv[3])
    yvel = float(sys.argv[4])
    simu_steps = int(float(sys.argv[5]) * 10)
    init_angle = float(sys.argv[6])
    rx2 = float(sys.argv[7])
    ry2 = float(sys.argv[8])
    xvel2 = float(sys.argv[9])
    yvel2 = float(sys.argv[10])
    simu_steps2 = int(float(sys.argv[11]) * 10)
    init_angle2 = float(sys.argv[12])
    rtor = float(sys.argv[13])
    rtor2 = float(sys.argv[14])
    gx = float(sys.argv[15])
    gy = float(sys.argv[16])
    gx2 = float(sys.argv[17])
    gy2 = float(sys.argv[18])
    
    
    world = b2WorldInterface(False)
    oshape, osize, ofriction, odensity, bfriction, hand_shape, hand_size  = 'circle', 1, 0.01, 0.05, 0.01, 'rectangle', (1,0.3) #'circle', 0.3#
    #thing,base = make_thing(500, 500, world, oshape, osize, ofriction, odensity, bfriction, (0,0))
    base = make_base(500, 500, world)
    thing = make_1thing(base, world, 'rectangle', (0.5,0.5), ofriction, odensity, (0, 2))
    thing2 = make_1thing(base, world, 'circle', 1, ofriction, odensity, (0,-2))
    #xvel = np.cos(init_angle)*5;
    #yvel = np.sin(init_angle)*5;
    robot = end_effector(world, (rx,ry), base, init_angle, hand_shape, hand_size)
    robot2 = end_effector(world, (rx2,ry2), base, init_angle2, hand_shape, hand_size)
    (ret1, ret2) = simu_push_2robot2thing(world, thing, thing2, robot, robot2, base, xvel, yvel, xvel2, yvel2, rtor, rtor2, simu_steps, simu_steps2)
    #print ret1, ret2
    ret1 = np.linalg.norm(np.array([gx, gy]) - ret1)
    ret2 = np.linalg.norm(np.array([gx2, gy2]) - ret2)
    sys.stdout.write(str(ret1+ret2))
File Path: test_functions/python_related/push_world.py
Content:
#!/usr/bin/env python
# Author: Ari Anders and Zi Wang
from Box2D import *
from Box2D.b2 import *
import numpy as np
import pygame
import scipy.io
from numpy import linalg as LA

# this just makes pygame show what's going on    
class guiWorld:
    def __init__(self, fps):
        self.SCREEN_WIDTH, self.SCREEN_HEIGHT = 1000, 1000
        self.TARGET_FPS = fps
        self.PPM = 10.0 # pixels per meter
        self.screen = pygame.display.set_mode((self.SCREEN_WIDTH, self.SCREEN_HEIGHT), 0, 32)
        pygame.display.set_caption('push simulator')
        self.clock = pygame.time.Clock()
        self.screen_origin = b2Vec2(self.SCREEN_WIDTH/(2*self.PPM), self.SCREEN_HEIGHT/(self.PPM*2))
        self.colors = {
            b2_staticBody : (255,255,255,255), 
            b2_dynamicBody : (163,209,224,255)
            }

    def draw(self, bodies, bg_color=(64,64,64,0)):
    #def draw(self, bodies, bg_color=(0,0,0,0)):
        def my_draw_polygon(polygon, body, fixture):
            vertices=[(self.screen_origin + body.transform*v)*self.PPM for v in polygon.vertices]
            vertices=[(v[0], self.SCREEN_HEIGHT-v[1]) for v in vertices]
            color = self.colors[body.type]
            if body.userData == "obs":
                color = (123,128,120,0)
            if body.userData == "hand":
                color = (174,136,218,0)

            pygame.draw.polygon(self.screen, color, vertices)
            
        def my_draw_circle(circle, body, fixture):
            position=(self.screen_origin + body.transform*circle.pos)*self.PPM
            position=(position[0], self.SCREEN_HEIGHT-position[1])
            color = self.colors[body.type]
            if body.userData == "hand":
                color = (174,136,218,0)
            pygame.draw.circle(self.screen, color, [int(x) for x in
            position], int(circle.radius*self.PPM))

        b2PolygonShape.draw=my_draw_polygon
        b2CircleShape.draw=my_draw_circle
        # draw the world
        self.screen.fill(bg_color)
        self.clock.tick(self.TARGET_FPS) 
        for body in bodies:
            for fixture in body.fixtures:
                fixture.shape.draw(body,fixture)
        pygame.display.flip()

# this is the interface to pybox2d
class b2WorldInterface:
    def __init__(self, do_gui=True):
        self.world = b2World(gravity=(0.0,0.0), doSleep=True)
        self.do_gui = do_gui
        self.TARGET_FPS = 100
        self.TIME_STEP = 1.0/self.TARGET_FPS
        self.VEL_ITERS, self.POS_ITERS =10,10
        self.bodies = []

        if do_gui:
            self.gui_world  = guiWorld(self.TARGET_FPS)
            #raw_input()
        else:
            self.gui_world = None

    def initialize_gui(self):
        if self.gui_world == None:
            self.gui_world = guiWorld(self.TARGET_FPS)
        self.do_gui = True
    def stop_gui(self):
        self.do_gui = False

    def add_bodies(self, new_bodies):
        """ add a single b2Body or list of b2Bodies to the world"""
        if type(new_bodies) == list:
            self.bodies += new_bodies
        else:
            self.bodies.append(new_bodies)
    def step(self, show_display=True, idx=0):
        self.world.Step(self.TIME_STEP, self.VEL_ITERS, self.POS_ITERS)
        if show_display and self.do_gui:
            self.gui_world.draw(self.bodies)
            #if idx % 10 == 0:
            #    pygame.image.save(self.gui_world.screen,'tmp_images/'+str(int(sm.ttt*100)+idx)+'.bmp')

class end_effector:
    def __init__(self, b2world_interface, init_pos, base, init_angle, hand_shape='rectangle', hand_size=(0.3,1)):
        world= b2world_interface.world
        self.hand = world.CreateDynamicBody(position=init_pos,angle=init_angle)
        self.hand_shape = hand_shape
        self.hand_size = hand_size
        # forceunit for circle and rect
        if hand_shape == 'rectangle':
            rshape = b2PolygonShape(box=hand_size)
            self.forceunit = 30.0
        elif hand_shape == 'circle':
            rshape = b2CircleShape(radius=hand_size)
            self.forceunit = 100.0
        elif hand_shape == 'polygon':
            rshape = b2PolygonShape(vertices=hand_size)
        else:
            raise Exception("%s is not a correct shape" % hand_shape)

        self.hand.CreateFixture(
            shape = rshape,
            density = .1,
            friction = .1
            )
        self.hand.userData = "hand"
        
        friction_joint = world.CreateFrictionJoint(
            bodyA = base,
            bodyB = self.hand,
            maxForce = 2,
            maxTorque = 2,
            )
        b2world_interface.add_bodies(self.hand)

        

    def set_pos(self, pos, angle):
        self.hand.position = pos
        self.hand.angle = angle
    def apply_wrench(self, rlvel=(0,0), ravel=0):
        #self.hand.ApplyForce(force, self.hand.position,wake=True)
        #if avel != 0:
        
        avel = self.hand.angularVelocity
        delta_avel = ravel - avel
        torque = self.hand.mass*delta_avel*30.0
        self.hand.ApplyTorque(torque, wake=True)
        
        #else:
        lvel = self.hand.linearVelocity
        delta_lvel = b2Vec2(rlvel) - b2Vec2(lvel)
        force = self.hand.mass*delta_lvel*self.forceunit
        self.hand.ApplyForce(force, self.hand.position,wake=True)
        

    def get_state(self, verbose=False):
        state = list(self.hand.position) + [ self.hand.angle] +  \
                list(self.hand.linearVelocity) + [self.hand.angularVelocity]
        if verbose:
            print_state = ["%.3f" % x for x in state]
            print "position, velocity: (%s), (%s) " % \
                ((", ").join(print_state[:3]), (", ").join(print_state[3:]) )
    
        return state

def make_thing(table_width, table_length, b2world_interface, thing_shape, thing_size, thing_friction, thing_density, base_friction, obj_loc):
    world = b2world_interface.world
    base = world.CreateStaticBody(
            position = (0,0),
            #friction = base_friction,
            shapes = b2PolygonShape(box=(table_length,table_width)),
            )

    link = world.CreateDynamicBody(position=obj_loc)
    if thing_shape == 'rectangle':
        linkshape = b2PolygonShape(box=thing_size)
    elif thing_shape == 'circle':
        linkshape = b2CircleShape(radius=thing_size)
    elif thing_shape == 'polygon':
        linkshape = b2PolygonShape(vertices=thing_size)
    else:
        raise Exception("%s is not a correct shape" % thing_shape)
    
    link.CreateFixture(
            shape = linkshape, 
            density = thing_density,
            friction = thing_friction,
            )
    friction_joint = world.CreateFrictionJoint(
            bodyA = base,
            bodyB = link,
            maxForce = 5,
            maxTorque = 2,
            )

    b2world_interface.add_bodies([base,link])
    return link,base


def simu_push(world, thing, robot, base, simulation_steps):
    # simulating push with fixed direction pointing from robot location to thing location 
    desired_vel = thing.position - robot.hand.position
    desired_vel = desired_vel / np.linalg.norm(desired_vel) * 5
    rvel = b2Vec2(desired_vel[0]+np.random.normal(0,0.1),desired_vel[1]+np.random.normal(0,0.1))

    rstop = False
    for t in range(simulation_steps+100):
        if not rstop:
            robot.apply_wrench(rvel)
        world.step()

        ostate = list(thing.position) + [ thing.angle] +  \
                list(thing.linearVelocity) + [thing.angularVelocity]
        if t == simulation_steps - 1:
            rstop = True
    return list(thing.position)
def simu_push2(world, thing, robot, base, xvel, yvel, simulation_steps):
    desired_vel = np.array([xvel, yvel])
    rvel = b2Vec2(desired_vel[0]+np.random.normal(0,0.1),desired_vel[1]+np.random.normal(0,0.1))

    rstop = False
    for t in range(simulation_steps+100):
        if not rstop:
            robot.apply_wrench(rvel)
        world.step()

        ostate = list(thing.position) + [ thing.angle] +  \
                list(thing.linearVelocity) + [thing.angularVelocity]
        if t == simulation_steps - 1:
            rstop = True
    return list(thing.position)

def make_1thing(base, b2world_interface, thing_shape, thing_size, thing_friction, thing_density, obj_loc):
    world = b2world_interface.world
    
    link = world.CreateDynamicBody(position=obj_loc)
    if thing_shape == 'rectangle':
        linkshape = b2PolygonShape(box=thing_size)
    elif thing_shape == 'circle':
        linkshape = b2CircleShape(radius=thing_size)
    elif thing_shape == 'polygon':
        linkshape = b2PolygonShape(vertices=thing_size)
    else:
        raise Exception("%s is not a correct shape" % thing_shape)
    
    link.CreateFixture(
            shape = linkshape, 
            density = thing_density,
            friction = thing_friction,
            )
    friction_joint = world.CreateFrictionJoint(
            bodyA = base,
            bodyB = link,
            maxForce = 5,
            maxTorque = 2,
            )

    b2world_interface.add_bodies([link])
    return link
def simu_push_2robot2thing(world, thing, thing2, robot, robot2, base, xvel, yvel, xvel2, yvel2, rtor, rtor2, simulation_steps, simulation_steps2):
    desired_vel = np.array([xvel, yvel])
    rvel = b2Vec2(desired_vel[0]+np.random.normal(0,0.01),desired_vel[1]+np.random.normal(0,0.01))
    
    desired_vel2 = np.array([xvel2, yvel2])
    rvel2 = b2Vec2(desired_vel2[0]+np.random.normal(0,0.01),desired_vel2[1]+np.random.normal(0,0.01))
    tmax = np.max([simulation_steps,simulation_steps2])
    for t in range(tmax+100):
        if t < simulation_steps:
            robot.apply_wrench(rvel, rtor)
        if t < simulation_steps2:
            robot2.apply_wrench(rvel2, rtor2)
        world.step()

    return (list(thing.position), list(thing2.position))
def make_base(table_width, table_length, b2world_interface):
    world = b2world_interface.world
    base = world.CreateStaticBody(
            position = (0,0),
            #friction = base_friction,
            shapes = b2PolygonShape(box=(table_length,table_width)),
            )
   

    b2world_interface.add_bodies([base])
    return base
Output:
{
    "experimental_code": "class b2WorldInterface:\n    def __init__(self, do_gui=True):\n        self.world = b2World(gravity=(0.0,0.0), doSleep=True)\n        self.do_gui = do_gui\n        self.TARGET_FPS = 100\n        self.TIME_STEP = 1.0/self.TARGET_FPS\n        self.VEL_ITERS, self.POS_ITERS =10,10\n        self.bodies = []\n\n        if do_gui:\n            self.gui_world  = guiWorld(self.TARGET_FPS)\n            #raw_input()\n        else:\n            self.gui_world = None\n\n    def initialize_gui(self):\n        if self.gui_world == None:\n            self.gui_world = guiWorld(self.TARGET_FPS)\n        self.do_gui = True\n    def stop_gui(self):\n        self.do_gui = False\n\n    def add_bodies(self, new_bodies):\n        \"\"\" add a single b2Body or list of b2Bodies to the world\"\"\"\n        if type(new_bodies) == list:\n            self.bodies += new_bodies\n        else:\n            self.bodies.append(new_bodies)\n    def step(self, show_display=True, idx=0):\n        self.world.Step(self.TIME_STEP, self.VEL_ITERS, self.POS_ITERS)\n        if show_display and self.do_gui:\n            self.gui_world.draw(self.bodies)\n            #if idx % 10 == 0:\n            #    pygame.image.save(self.gui_world.screen,'tmp_images/'+str(int(sm.ttt*100)+idx)+'.bmp')\n\nclass end_effector:\n    def __init__(self, b2world_interface, init_pos, base, init_angle, hand_shape='rectangle', hand_size=(0.3,1)):\n        world= b2world_interface.world\n        self.hand = world.CreateDynamicBody(position=init_pos,angle=init_angle)\n        self.hand_shape = hand_shape\n        self.hand_size = hand_size\n        # forceunit for circle and rect\n        if hand_shape == 'rectangle':\n            rshape = b2PolygonShape(box=hand_size)\n            self.forceunit = 30.0\n        elif hand_shape == 'circle':\n            rshape = b2CircleShape(radius=hand_size)\n            self.forceunit = 100.0\n        elif hand_shape == 'polygon':\n            rshape = b2PolygonShape(vertices=hand_size)\n        else:\n            raise Exception(\"%s is not a correct shape\" % hand_shape)\n\n        self.hand.CreateFixture(\n            shape = rshape,\n            density = .1,\n            friction = .1\n            )\n        self.hand.userData = \"hand\"\n        \n        friction_joint = world.CreateFrictionJoint(\n            bodyA = base,\n            bodyB = self.hand,\n            maxForce = 2,\n            maxTorque = 2,\n            )\n        b2world_interface.add_bodies(self.hand)\n\n        \n\n    def set_pos(self, pos, angle):\n        self.hand.position = pos\n        self.hand.angle = angle\n    def apply_wrench(self, rlvel=(0,0), ravel=0):\n        #self.hand.ApplyForce(force, self.hand.position,wake=True)\n        #if avel != 0:\n        \n        avel = self.hand.angularVelocity\n        delta_avel = ravel - avel\n        torque = self.hand.mass*delta_avel*30.0\n        self.hand.ApplyTorque(torque, wake=True)\n        \n        #else:\n        lvel = self.hand.linearVelocity\n        delta_lvel = b2Vec2(rlvel) - b2Vec2(lvel)\n        force = self.hand.mass*delta_lvel*self.forceunit\n        self.hand.ApplyForce(force, self.hand.position,wake=True)\n        \n\n    def get_state(self, verbose=False):\n        state = list(self.hand.position) + [ self.hand.angle] +  \\\n                list(self.hand.linearVelocity) + [self.hand.angularVelocity]\n        if verbose:\n            print_state = [\"%.3f\" % x for x in state]\n            print \"position, velocity: (%s), (%s) \" % \\\n                ((\", \").join(print_state[:3]), (\", \").join(print_state[3:]) )\n    \n        return state\n\ndef make_1thing(base, b2world_interface, thing_shape, thing_size, thing_friction, thing_density, obj_loc):\n    world = b2world_interface.world\n    \n    link = world.CreateDynamicBody(position=obj_loc)\n    if thing_shape == 'rectangle':\n        linkshape = b2PolygonShape(box=thing_size)\n    elif thing_shape == 'circle':\n        linkshape = b2CircleShape(radius=thing_size)\n    elif thing_shape == 'polygon':\n        linkshape = b2PolygonShape(vertices=thing_size)\n    else:\n        raise Exception(\"%s is not a correct shape\" % thing_shape)\n    \n    link.CreateFixture(\n            shape = linkshape, \n            density = thing_density,\n            friction = thing_friction,\n            )\n    friction_joint = world.CreateFrictionJoint(\n            bodyA = base,\n            bodyB = link,\n            maxForce = 5,\n            maxTorque = 2,\n            )\n\n    b2world_interface.add_bodies([link])\n    return link\ndef simu_push_2robot2thing(world, thing, thing2, robot, robot2, base, xvel, yvel, xvel2, yvel2, rtor, rtor2, simulation_steps, simulation_steps2):\n    desired_vel = np.array([xvel, yvel])\n    rvel = b2Vec2(desired_vel[0]+np.random.normal(0,0.01),desired_vel[1]+np.random.normal(0,0.01))\n    \n    desired_vel2 = np.array([xvel2, yvel2])\n    rvel2 = b2Vec2(desired_vel2[0]+np.random.normal(0,0.01),desired_vel2[1]+np.random.normal(0,0.01))\n    tmax = np.max([simulation_steps,simulation_steps2])\n    for t in range(tmax+100):\n        if t < simulation_steps:\n            robot.apply_wrench(rvel, rtor)\n        if t < simulation_steps2:\n            robot2.apply_wrench(rvel2, rtor2)\n        world.step()\n\n    return (list(thing.position), list(thing2.position))\ndef make_base(table_width, table_length, b2world_interface):\n    world = b2world_interface.world\n    base = world.CreateStaticBody(\n            position = (0,0),\n            #friction = base_friction,\n            shapes = b2PolygonShape(box=(table_length,table_width)),\n            )\n   \n\n    b2world_interface.add_bodies([base])\n    return base",
    "experimental_info": "The provided repository content does not contain the implementation of the DNN-MFBO method itself. Instead, it provides a physics-based simulation environment that the DNN-MFBO method would likely be applied to or optimize. The extracted code sections define the core components and logic of this simulation environment.\n\n**Experimental Setup for DNN-MFBO:**\n- **Task:** The objective is to optimize control parameters for one or two robots to push one or two objects (circular or rectangular) towards specific target goal positions in a 2D Box2D physics simulation.\n- **Design Variables (Input `x` for DNN-MFBO):** The parameters that DNN-MFBO would optimize include:\n    - Initial robot positions (`rx`, `ry`).\n    - Robot push velocities (`xvel`, `yvel` for each robot).\n    - Robot initial angles or applied torques (`init_angle`, `rtor` for each robot).\n    These parameters directly influence the push actions within the simulation.\n- **Objective Function (High Fidelity `fM(x)` for DNN-MFBO):** The goal is to minimize the total Euclidean distance between the final position(s) of the pushed object(s) and their respective target goal position(s). For multiple objects, this is the sum of individual distances (e.g., `np.linalg.norm(goal1 - final_pos1) + np.linalg.norm(goal2 - final_pos2)`).\n- **Fidelity Parameter (`m` for DNN-MFBO):** The `simulation_steps` parameter (e.g., `simu_steps`, `simu_steps2`) directly controls the duration of the physics simulation. This serves as the fidelity variable (`m`) for DNN-MFBO. A lower number of `simulation_steps` corresponds to a lower-fidelity (faster, less computationally expensive, but potentially less accurate) simulation, while a higher number corresponds to a higher-fidelity simulation.\n- **Simulation Details:**\n    - Uses the Box2D physics engine (`pybox2d`).\n    - Simulates object-robot interactions, including applying forces and torques.\n    - Adds slight Gaussian noise (`np.random.normal`) to desired velocities during robot control. The simulation time step is `1.0/100` seconds."
}
